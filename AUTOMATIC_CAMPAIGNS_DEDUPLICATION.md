# Дедупликация инфлюенсеров в автоматических кампаниях

## Проблема

Один инфлюенсер может иметь **несколько карточек** (например, на разных платформах или с разными условиями сотрудничества), которые **все подходят** под критерии автоматической кампании.

**Без дедупликации:**
- Система отправила бы несколько предложений одному и тому же человеку
- Это нарушает логику "один аккаунт = одно участие"
- Расходуются слоты овербукинга на дубликаты

## Решение

### Алгоритм дедупликации

```typescript
1. Получить все карточки, подходящие под критерии
2. Сгруппировать карточки по userId
3. Для каждого userId:
   - Рассчитать среднюю цену каждой карточки
   - Выбрать карточку с минимальной ценой
4. Продолжить с дедуплицированным списком
```

### Пример

**Исходные данные:**

Инфлюенсер Иван (userId: `123`) имеет 2 карточки:

| Карточка | Платформа | Подписчики | Цена за пост | Цена за Story | Средняя цена |
|----------|-----------|------------|--------------|---------------|--------------|
| Card A   | Instagram | 50,000     | $500         | $300          | $400         |
| Card B   | Instagram | 50,000     | $400         | $250          | $325         |

**Автокомпания требует:** Instagram, 40k-60k подписчиков, Пост + Story

**Обе карточки подходят!**

### Работа алгоритма

```typescript
// Шаг 1: Группировка по userId
cardsByUser.set('123', [CardA, CardB])

// Шаг 2: Расчёт средней цены для каждой карточки
CardA: avgPrice = (500 + 300) / 2 = 400
CardB: avgPrice = (400 + 250) / 2 = 325

// Шаг 3: Сортировка по цене и выбор минимальной
sorted = [
  { card: CardB, avgPrice: 325 },  // ← Выбираем эту!
  { card: CardA, avgPrice: 400 }
]

// Шаг 4: В итоговый список попадает только CardB
deduplicatedCards.push(CardB)
```

**Результат:**
- Ивану отправится только **одно** предложение
- По карточке B (более выгодной для кампании)
- CardA игнорируется

---

## Реализация в коде

### Место в коде

Файл: `src/modules/campaigns/services/automaticCampaignService.ts`

Метод: `findAndScoreInfluencers()`

### Код дедупликации

```typescript
// ДЕДУПЛИКАЦИЯ: Группируем карточки по userId
const cardsByUser = new Map<string, InfluencerCard[]>();
for (const card of platformFiltered) {
  if (!cardsByUser.has(card.userId)) {
    cardsByUser.set(card.userId, []);
  }
  cardsByUser.get(card.userId)!.push(card);
}

// Для каждого инфлюенсера выбираем карточку с минимальной ценой
const deduplicatedCards: InfluencerCard[] = [];
for (const [userId, cards] of cardsByUser) {
  // Рассчитываем среднюю цену для каждой карточки
  const cardsWithPrice = cards.map(card => ({
    card,
    avgPrice: this.calculateInfluencerAveragePrice(card, campaign)
  }));

  // Сортируем по возрастанию цены и берём самую дешёвую
  cardsWithPrice.sort((a, b) => a.avgPrice - b.avgPrice);
  deduplicatedCards.push(cardsWithPrice[0].card);
}
```

---

## Влияние на бизнес-логику

### До дедупликации

```
Автокомпания: N=100, Овербукинг=25%
→ Может отправить до 125 предложений

Если 10 инфлюенсеров имеют по 2 карточки:
→ Отправится 125 предложений
→ Но участников будет max ~115 (некоторые получат 2 предложения)
```

### После дедупликации

```
Автокомпания: N=100, Овербукинг=25%
→ Может отправить до 125 предложений

Если 10 инфлюенсеров имеют по 2 карточки:
→ Отправится 125 предложений
→ Все 125 - уникальным инфлюенсерам
→ Ожидаемое количество участников: 100 (корректно!)
```

---

## Преимущества

1. **Справедливость**
   - Один инфлюенсер = одна возможность участия
   - Нет "двойных шансов" для тех, у кого несколько карточек

2. **Эффективность овербукинга**
   - Все слоты используются на уникальных людей
   - Овербукинг работает как задумано

3. **Оптимизация бюджета**
   - Автоматически выбирается самая выгодная карточка
   - Экономия средств кампании

4. **Корректность метрик**
   - Метрики "отправлено предложений" и "уникальных получателей" совпадают
   - Прогнозирование работает точнее

---

## Краевые случаи

### Случай 1: Разные цены для разных типов контента

**Ситуация:**
- Кампания требует: Пост + Story + Reels
- CardA: Пост=$100, Story=$50, Reels=$200 → avg=$116.67
- CardB: Пост=$150, Story=$70, Reels=$150 → avg=$123.33

**Решение:** Выбирается CardA (меньшая средняя цена)

### Случай 2: Карточка не имеет цены на требуемый контент

**Ситуация:**
- Кампания требует: Reels
- CardA: Пост=$100, Story=$50, Reels не указан
- CardB: Пост=$150, Story=$70, Reels=$200

**Решение:**
- `calculateInfluencerAveragePrice()` вернёт 0 для CardA
- CardA будет отфильтрована на этапе `if (influencerPrice === 0) continue`
- Останется только CardB

### Случай 3: Обе карточки имеют одинаковую цену

**Ситуация:**
- CardA: avg=$300
- CardB: avg=$300

**Решение:**
- `sort()` стабильная, порядок сохраняется
- Выбирается та, что была первой в массиве (обычно более старая карточка)

---

## Тестирование

### Проверка дедупликации

```typescript
// 1. Создать тестового инфлюенсера с 2 карточками
const userId = 'test-user-123';

// CardA - дорогая
await createInfluencerCard({
  userId,
  platform: 'instagram',
  followers: 50000,
  pricing: { post: 500, story: 300 }
});

// CardB - дешёвая
await createInfluencerCard({
  userId,
  platform: 'instagram',
  followers: 50000,
  pricing: { post: 300, story: 200 }
});

// 2. Создать автокомпанию
const campaign = await automaticCampaignService.createCampaign({
  preferences: {
    platforms: ['instagram'],
    audienceSize: { min: 40000, max: 60000 },
    contentTypes: ['post', 'story']
  },
  ...
});

// 3. Проверить предложения
const offers = await getOffersByCampaign(campaign.id);

// Должно быть только 1 предложение
expect(offers.length).toBe(1);

// Должно быть по CardB (более дешёвой)
expect(offers[0].influencer_card_id).toBe(cardB.id);
```

---

## Мониторинг

### Метрики для отслеживания

1. **Коэффициент дедупликации**
   ```
   deduplicationRate =
     (исходное_количество_карточек - дедуплицированное) /
     исходное_количество_карточек * 100%
   ```

   Пример: 150 карточек → 125 уникальных = 16.7% дедупликации

2. **Средняя экономия на дедупликации**
   ```
   avgSavings =
     среднее(отброшенная_цена - выбранная_цена)
   ```

3. **Количество инфлюенсеров с множественными карточками**
   ```
   multiCardInfluencers = count(userId with > 1 matching cards)
   ```

---

## Итог

Дедупликация инфлюенсеров гарантирует:
- ✅ Один аккаунт участвует только один раз
- ✅ Автоматический выбор наиболее выгодной карточки
- ✅ Корректную работу овербукинга
- ✅ Оптимизацию бюджета кампании
- ✅ Справедливое распределение возможностей

Это критически важная часть бизнес-логики автоматических кампаний.
